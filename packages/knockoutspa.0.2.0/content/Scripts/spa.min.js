var spa = spa || {}; spa.entityStates = { unchanged: "unchanged", added: "added", removed: "removed", modified: "modified" }; spa.filterTypes = { Equal: "eq", NotEqual: "ne", GreaterThan: "gt", GreaterThanOrEqual: "ge", LessThan: "lt", LessThanOrEqual: "le", And: "and", Or: "or", Not: "not" }; spa.dataAdapter = function (controllerName) { this._controllerUrl = "/api/" + controllerName; }; spa.dataAdapter.prototype = {
    LoadOne: function (id, callBack) { $.ajax({ type: "POST", contentType: "application/json", dataType: "text json", url: this._controllerUrl + "/" + id, type: "GET", success: callBack, }); }, PostItem: function (data, callBack) { $.ajax({ type: "POST", contentType: "application/json", dataType: "text json", url: this._controllerUrl, data: data, success: callBack, }); }, PutItem: function (id, data, callBack) { $.ajax({ type: "PUT", contentType: "application/json", dataType: "text json", url: this._controllerUrl + "/" + id, data: data, success: callBack }); }, DeleteItem: function (id, callBack) { $.ajax({ type: "DELETE", contentType: "application/json", dataType: "text json", url: this._controllerUrl + "/" + id, statusCode: { 200: callBack.call(this), } }); }, QueryAll: function (callBack, query) {
        var url = this._controllerUrl; if (query) { url = url + "?" + query; }
        $.ajax({ type: "GET", contentType: "application/json", dataType: "text json", url: url, success: callBack, });
    }
}; spa.dataContext = function (bufferDefault) { this.buffer = bufferDefault || false; }; spa.dataContext.prototype = {
    AddSet: function (controllerName, keyPropertyName, buffer) {
        if (!this[controllerName]) { this[controllerName] = new spa.dataSet(controllerName, keyPropertyName, this.buffer, this); }
        return this[controllerName];
    }, FindEntity: function (controllerName, Key) { return this[controllerName].FindByKey(key); }
}; spa.dataSet = function (setName, keyPropertyName, buffer, dataContext) { this.DataSetName = setName; this.DataAdapter = new spa.dataAdapter(setName); this.Key = keyPropertyName; this.Buffer = buffer || false; this.Entities = {}; this.NewItems = []; this.PartOf = dataContext; }; spa.dataSet.prototype = {
    CreateView: function (query) { return new spa.dataView(this, query); }, Read: function (obsArray, query, refresh) {
        var self = this; this.DataAdapter.QueryAll(function (data) {
            obsArray.remove(function (entity) { return (entity.EntityState() != spa.entityStates.added); }); $.map(data, function (item) {
                var existing = self.FindByKey(item); if (existing) {
                    if (refresh) { existing.Update(item); }
                    if (existing.EntityState() != spa.entityStates.removed) { obsArray.push(existing); }
                }
                else { var newEntity = new spa.dataEntity(item); self.Attach(newEntity); obsArray.push(newEntity); }
            }); if (query.orderby().length > 0) {
                obsArray.sort(function (left, right) {
                    var ordering = query.orderby()[0]; var fldName = ko.utils.unwrapObservable(ordering.field); var l = ko.utils.unwrapObservable(left.Entity[fldName]); var r = ko.utils.unwrapObservable(right.Entity[fldName]); if (ordering.ascending) { return l == r ? 0 : (l < r ? -1 : 1); }
                    else { return l == r ? 0 : (l > r ? -1 : 1); }
                });
            }
        }, query.ToQueryString());
    }, Refresh: function (entity) { var keyToUpdate = dataEntity.Entity[this.Key](); this.DataAdapter.LoadOne(keyToUpdate, function (data) { entity.Update(data); }); }, Create: function (entity) { if (entity.IsSubmitting() == false) { var set = this; entity.IsSubmitting(true); this.DataAdapter.PostItem(entity.ToJSON(), function (data) { entity.IsSubmitting(false); entity.Update(data); set.NewItems.splice(set.NewItems.indexOf(entity), 1); set.Attach(entity); }); } }, Update: function (entity) { if (entity.IsSubmitting() == false) { var key = this.GetKey(entity.Entity); entity.IsSubmitting(true); this.DataAdapter.PutItem(key, entity.ToJSON(), function (data) { entity.IsSubmitting(false); entity.Merge(data); }); } }, Delete: function (entity) { if (entity.IsSubmitting() == false) { var key = this.GetKey(entity.Entity); var set = this; entity.IsSubmitting(true); this.DataAdapter.DeleteItem(key, function () { entity.IsSubmitting(false); set.Detach(entity); }); } }, Attach: function (entity) {
        var key = this.GetKey(entity.Entity); if (!this.Entities[key]) {
            if (!key) { this.NewItems.push(entity); if (this.Buffer === false) { this.Create(entity); } }
            else {
                this.Entities[key] = entity; if (this.Buffer === false) {
                    entity.EntityState.subscribe(function (newState) {
                        if (newState == spa.entityStates.modified) { this.Update(entity); }
                        else if (newState == spa.entityStates.removed) { this.Delete(entity); }
                    }, this);
                }
            }
        }
    }, Detach: function (entity) { var keyToFind = entity.Entity[this.Key](); if (this.Entities[keyToFind]) { delete this.Entities[keyToFind]; } }, GetKey: function (entity) { return ko.utils.unwrapObservable(entity[this.Key]); }, FindByKey: function (entity) {
        var keyToFind = ko.utils.unwrapObservable(entity[this.Key]); if (this.Entities[keyToFind]) { return this.Entities[keyToFind]; }
        else { return null; }
    }, GetChanges: function () {
        var c = []; for (key in this.Entities) { if (this.Entities[key].HasChanges()) { c.push(this.Entities[key]); } }
        return c;
    }, GetRemoved: function () {
        var c = []; for (key in this.Entities) { if (this.Entities[key].EntityState() === spa.entityStates.removed) { c.push(this.Entities[key]); } }
        return c;
    }, SaveAll: function () {
        for (var i = 0, l = this.NewItems.length; i < l; i++) { this.Create(this.NewItems[i]); }
        var changes = this.GetChanges(); for (var i = 0, l = changes.length; i < l; i++) { this.Update(changes[i]); }
        var deletes = this.GetRemoved(); for (var i = 0, l = deletes.length; i < l; i++) { this.Delete(deletes[i]); }
    }
}; spa.dataView = function (dataSet, query) { this.DataSet = dataSet; this.Query = query || new spa.odataQuery(); this.ViewItems = ko.observableArray(); }; spa.dataView.prototype = { AddItem: function (newItem) { newItem.EntityState(spa.entityStates.added); this.DataSet.Attach(newItem); this.ViewItems.push(newItem); }, DeleteItem: function (toDelete) { toDelete.EntityState(spa.entityStates.removed); this.ViewItems.remove(toDelete); }, SaveAll: function () { this.DataSet.SaveAll(); }, Refresh: function (overwrite) { this.DataSet.Read(this.ViewItems, this.Query, overwrite); }, }; spa.ordering = function (field, ascending) { this.field = ko.observable(field); this.ascending = ascending || true; }
spa.ordering.prototype = {
    ToOrderString: function () {
        if (this.ascending) { return ko.utils.unwrapObservable(this.field) + " asc"; }
        else { return ko.utils.unwrapObservable(this.field) + " desc"; }
    }
}; spa.odataQuery = function () { this.pageNum = ko.observable(0); this.pageSize = ko.observable(0); this.orderby = ko.observableArray(); this.filter = undefined; }; spa.odataQuery.prototype = {
    ToQueryString: function () {
        if ((this.pageNum() != 0 || this.pageSize() != 0) && this.orderby.length > 0) { throw "You must specify atleast 1 order function when using paging"; }
        if (this.pageNum() != 0 && this.pageSize() == 0) { throw "You cannot specify a page number without a page size"; }
        var qstring = []; if (this.filter) { qstring.push("$filter=" + this.filter); }
        if (this.pageNum()) { qstring.push("$skip=" + (this.pageSize() * this.pageNum())); }
        if (this.pageSize()) { qstring.push("$top=" + this.pageSize()); }
        var orders = []; for (var ord in this.orderby()) { orders.push(this.orderby()[ord].ToOrderString()); }
        if (orders.length) { qstring.push("$orderby=" + orders.join(", ")); }
        return qstring.join("&");
    }
}; spa.dataEntity = function (data, initialState) {
    var self = this; self._origData = data; self._persistData = null; self.Entity = ko.mapping.fromJS(data); self.EntityState = ko.observable(initialState || spa.entityStates.unchanged); self.IsSubmitting = ko.observable(false); self.HasChanges = ko.computed(function () {
        for (var prop in self._origData) {
            if (self._origData[prop] != ko.utils.unwrapObservable(self.Entity[prop])) {
                if (self.EntityState() == spa.entityStates.unchanged) { self.EntityState(spa.entityStates.modified); }
                return true;
            }
        }
        if (self.EntityState() == spa.entityStates.modified) { self.EntityState(spa.entityStates.unchanged); }
        return false;
    });
}; spa.dataEntity.prototype = {
    Update: function (data) {
        this._origData = data; for (prop in data) { if (data[prop] != ko.utils.unwrapObservable(this.Entity[prop])) { this.Entity[prop](data[prop]); } }
        this.EntityState(spa.entityStates.unchanged);
    }, Merge: function (data) {
        var newMods = false; var lastSubmit = JSON.parse(this._persistData) || this._origData; for (prop in data) { if (lastSubmit[prop] != data[prop]) { newMods = true; break; } }
        this._origData = data; for (prop in data) { if (data[prop] != ko.utils.unwrapObservable(this.Entity[prop])) { this.Entity[prop](data[prop]); } }
        if (newMods == false) { this.EntityState(spa.entityStates.unchanged); }
        else { this.EntityState(spa.entityStates.modified); }
    }, ToJSON: function () { this._persistData = ko.mapping.toJSON(this.Entity); return this._persistData; },
};